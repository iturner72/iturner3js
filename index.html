<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Digital Trinket</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="./styles/main.css">
	</head>

	<body>
		<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - OBJLoader test
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./js/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';

			import { OBJLoader } from './node_modules/three/examples/jsm/loaders/OBJLoader.js';
			import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';

			let container, stats;

			let camera, scene, renderer;

			let pointLight;

			var pivotPoint;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.z = 2500;

				//cubemap
				const path = './styles/';
				const format = '.jpg';
				const urls = [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				];

				const reflectionCube = new THREE.CubeTextureLoader().load( urls );
				const refractionCube = new THREE.CubeTextureLoader().load( urls );
				refractionCube.mapping = THREE.CubeRefractionMapping;

				// scene
				scene = new THREE.Scene();
				scene.background = reflectionCube;

				// lights
				const ambient= new THREE.AmbientLight( 0xffffff, 3.2 );
				scene.add( ambient );

				const pointLight = new THREE.PointLight( 0xffffff, 2.2 );
				pointLight.position.set( 0, 0, 15);
				scene.add( pointLight );

				//materials
				const trinketMaterial3 = new THREE.MeshLambertMaterial( { color: 0xff5733, envMap: reflectionCube, combine: THREE.MixOperation, reflectivity: .87 } );
				const trinketMaterial2 = new THREE.MeshLambertMaterial( { color: 0x40e0d0, envMap: refractionCube, refractionRatio: 0.22 } );
				const trinketMaterial1 = new THREE.MeshLambertMaterial( { color: 0x000000, envMap: reflectionCube } );


				const objLoader = new OBJLoader();

					objLoader.setPath('./styles/');
					objLoader.load( 'OTB_Digital_Trinket_Draft.obj', function ( object ) {

					const trink = object.children[ 0 ];


					trink.scale.multiplyScalar( 6 );
					trink.position.y = 0;
					trink.position.z = 0;
					trink.material = trinketMaterial1;

					const trink2 = trink.clone();
					trink2.position.x = 0;
					trink2.material = trinketMaterial2;

					const trink3 = trink.clone();
					trink3.position.x = 0;
					trink3.material = trinketMaterial3;


					scene.add(trink, trink2, trink3);

					// Pivot Point
					pivotPoint = new THREE.Object3D();
					trink.add(pivotPoint);

					trink2.position.set( 0, 0, -50)
					pivotPoint.add(trink2);
					trink3.position.set( 0, 0, -50)
					pivotPoint.add(trink3);

					} );


				// renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );


				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.enableZoom = false;
				controls.enablePan = false;
				controls.minPolarAngle = Math.PI / 4;
				controls.maxPolarAngle = Math.PI / 1.5;

				// stats
				stats = new Stats()
				container.appendChild( stats.dom );

				window.addEventListener('resize', onWindowResize );

			}


			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}



			function animate() {

				requestAnimationFrame( animate );
				render();

				stats.update()

			}


			function render() {


				pivotPoint.rotation.y += 0.01;
				pivotPoint.rotation.z += 0.01;

				renderer.render( scene, camera );
				stats.update()

			}






		</script>
	</body>
</html>
